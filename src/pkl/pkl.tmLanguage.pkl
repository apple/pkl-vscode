//===----------------------------------------------------------------------===//
// Copyright Â© 2024 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//

amends "tmLanguage.pkl"

name = "Pkl"

scopeName = "source.pkl"

uuid = "0598575b-33f4-42c1-b797-5b93a6cfc03a"

fileTypes {
  "pkl"
  "pcf"
}

foldingStartMarker = "\\{"

foldingStopMarker = "}"

local function escape(numPounds: Int): MatchPattern = new {
  name = "constant.character.escape.\(numPounds).pkl"
  local escapeChar = #"\\"# + "\\#".repeat(numPounds)
  match = #"""
    (?x:                 # turn on extended mode
      \#(escapeChar)
      (?:
        [trn"\\]         # tab, carriage return, newline, quote, backslash
        |                # OR
        u                # the letter u
        \{               # curly opening brace literal
        [\da-fA-F]+      # 1 or more hex number literal
        }                # curly end literal
        |                # OR
        \(               # interpolation start
        .+?              # one or more characters lazily (correct syntax highlighting within here should be provided by semantic tokens)
        \)               # interpolation end
      )
      |                  # OR
      (                  # capture group: invalid escape
        \#(escapeChar)   # the escape char
        .                # any character
      )
    )
    """#
  captures {
    ["1"] {
      name = "invalid.illegal.unrecognized-string-escape.pkl"
    }
  }
}

local function singlelineString(numPounds: Int): BeginEndPattern = new {
  name = "string.quoted.double.\(numPounds).pkl"
  local pounds = "#".repeat(numPounds)
  local stringStart = "(" + pounds + "\"" + ")"
  local stringEnd = "(" + "\"" + pounds.replaceAll("#", "\\#") + ")"
  begin = stringStart
  beginCaptures {
    ["1"] { name = "punctuation.delimiter.pkl" }
  }
  end = #"""
    (?x:
      \#(stringEnd)         # string end
      |                     # OR
      (.?$)                 # error; unterminated string (flag last character as an error)
    )
    """#
  endCaptures {
    ["1"] { name = "punctuation.delimimter.pkl" }
    ["2"] { name = "invalid.illegal.newline.pkl" }
  }
  patterns {
    escape(numPounds)
  }
}

local function multilineString(numPounds: Int): BeginEndPattern = new {
  local pounds = "#".repeat(numPounds)
  name = "string.quoted.triple.\(numPounds).pkl"
  begin = #"""
    (\#(pounds)""")
    """#
  end = #"""
    ("""\#(pounds))
    """#
  captures {
    ["1"] {
      name = "punctuation.delimiter.pkl"
    }
  }
  patterns {
    escape(numPounds)
  }
}

local languageConstant: Pattern = new KeywordMatchPattern {
  name = "constant.character.language.pkl"
  // language=regexp
  keywords {
    "true"
    "false"
    "null"
  }
}.pattern

local lineComment: MatchPattern = new {
  name = "comment.line.pkl"
  match = "//.*"
}

local blockComment: BeginEndPattern = new {
  name = "comment.block.pkl"
  // language=regexp
  begin = "/\\*"
  // language=regexp
  end = "\\*/"
}

local modifier: Pattern = new KeywordMatchPattern {
  name = "storage.modifier.pkl"
  keywords {
    "hidden"
    "local"
    "abstract"
    "external"
    "open"
    "in"
    "out"
    "amends"
    "extends"
    "fixed"
    "const"
  }
}.pattern

local controlKeyword: Pattern = new KeywordMatchPattern {
  name = "keyword.control.pkl"
  keywords {
    "if"
    "else"
    "when"
    "for"
    "import"
    "new"
  }
}.pattern

local class KeywordMatchPattern {
  local self = this
  name: String
  keywords: Listing<String>(isDistinct)

  pattern: MatchPattern = new {
    name = self.name
    match = new Listing {
      "\\b"
      "("
      keywords.join("|")
      ")"
      "\\b"
    }.join("")
  }
}

local symbolOperator: MatchPattern = new {
  name = "keyword.operator.pkl"
  match = #"""
    (?x:
      # MATH
      \+    # add
      |
      -     # minus
      |
      \*    # multiply
      |
      /     # divide
      |
      ~/    # integer divide
      |
      %     # modulo
      |
      \*\*  # power
      |
      >     # greater than
      |
      >=    # greater than or equals
      |
      <     # less than
      |
      <=    # less than or equals
      |
      ==    # equals
      |
      !=    # not equals

      # LOGICAL
      |
      !     # unary not
      |
      &&    # and
      |
      \|\|  # or
      |

      # MISCELLANEOUS
      \|>   # function pipe
      |
      \?\?  # nullish coalesce
      |
      !!    # non-null assertion
      |
      =     # assignment
      |
      ->    # lambda arrow
      |
      \|    # type union
    )
    """#
}

local punctuation: MatchPattern = new {
  name = "punctuation.pkl"
  match = #"""
    (?x:
      \.\?  # optional chain
      |
      \.    # member access
      |
      ;     # semicolon
      |
      :     # colon
    )
    """#
}

local keywordOperator: MatchPattern = new KeywordMatchPattern {
  name = "keyword.pkl"
  keywords {
    "amends"
    "as"
    "extends"
    "function"
    "is"
    "let"
    "read"
    "read\\?"
    "import"
    "throw"
    "trace"
  }
}.pattern


local builtInVariable: Pattern = new KeywordMatchPattern {
  name = "variable.language.pkl"
  // language=regexp
  keywords {
    "this"
    "module"
    "outer"
    "super"
  }
}.pattern

local builtInTypes: Pattern = new KeywordMatchPattern {
  name = "support.type.pkl"
  keywords {
    "unknown"
    "never"
  }
}.pattern

local braces: MatchPattern = new {
  name = "meta.brace.pkl"
  match = #"[(){}\[\]]"#
}

local intLiteral: MatchPattern = new {
  name = "constant.numeric.pkl"
  match = #"""
    (?x:               # extended mode
      \b
      (?:
        0x[\da-fA-F]+  # 1 or more hex literal
        |
        0b[0-1]+       # 1 or more binary literal
        |
        \d+            # 1 or more decimal literal
      )
      \b
    )
    """#
}

local floatLiteral: MatchPattern = new {
  name = "constant.numeric.pkl"
  match = #"""
    (?x:
      \b
      (?:
        \d*                 # 0 or more digits
        \.                  # dot literal
        \d+                 # 1 or mor digits
        (?:[eE][+-]?\d+)?   # optional exponent
        |                   # OR
        \d+                 # 1 or more digits
        [eE][+-]?\d+        # exponent
      )
      \b
    )
    """#
}

local classKeyword: Pattern = new KeywordMatchPattern {
  name = "keyword.class.pkl"
  keywords {
    "class"
    "typealias"
  }
}.pattern

patterns {
  languageConstant
  lineComment
  blockComment
  modifier
  keywordOperator
  controlKeyword
  intLiteral
  floatLiteral
  symbolOperator
  builtInVariable
  builtInTypes
  braces
  classKeyword
  punctuation
  for (numPounds in IntSeq(0, 6)) {
    multilineString(numPounds)
    singlelineString(numPounds)
  }
}
